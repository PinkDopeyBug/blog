---
title: 11 语法
createTime: 2025/06/22 10:51:08
permalink: /cpp/c/11/
---
## 数据类型相关的关键字
用于定义变量或类型
### 使用方法
类型 变量名:

### 关键字类型
1.  char 字符型 占1字节
`char ch1=‘1’   正确
char ch2=‘1234’   错误 多个字符，不能用单引号`

2. short 短整型 占2字节
配合int使用
`short int a=11;`
没有使用signed和unsigned修饰时是默认有符号的，只能使用正整数，负整数，0进行赋值
范围：16位 -32768~32767

3. int 整形 在32位系统下占4字节，16位系统下占2字节
`int a=44`
默认有符号
范围：32位 -20亿~20亿

4. long 长整型 32位平台下占4字节
`long int a=66`
范围：32位 -20亿~20亿

5. float 单浮点型 占4字节
范围：7位有效数字，指数-37到38
`float b=3.8f;`  小数后面要加f修饰，否则会默认为double型

6. double 双浮点型 占8字节
范围：16位有效数字，指数-307到308
精度比单浮点型更高，范围更大
`double b=3.8;`


7. struct 结构体
可以定义结构体类型，也可以定义结构体变量

8. union 联合体（共用体）

9. enum 枚举类型

10. signed 有符号数
用于修饰char、short、int、long
`signed int a=10;
signed int b=-6;`
默认情况下signed可以省略

11. unsigned 无符号数
用于修饰char、short、int、long
`unsigned int a=101;
unsigned int b=-101;   错误`

12. viod 空类型
不能定义变量，一般用来修饰函数的参数或者返回值，代表函数没有参数或返回值
例：
```c
void fun(void){}
```
代表fun函数没有返回值，也没有参数

## 存储相关的关键字
1. register修饰寄存器变量
在编译的时候告诉编译器这个变量是寄存器变量，尽量 将其存储空间分配在寄存器中
数据只有存储在内存中才有地址编号，用register修饰的变量不能用取地址符对其取地址
不一定在寄存器当中
cpu去寄存器中取数据比去内存中取数据快
不能定义数组，因为寄存器比较宝贵
只能修饰字符型和整形不能修饰浮点型

`register chr ch;
register short int b;
register float d;   错误`

`register int a;
int *p;
p=&a;   错误，a可能没有地址`

2. static静态
修饰全局变量 局部变量，函数

3. const常量
修饰的变量是只读的，不能修改它的值
`const int a=101;  ` 在定义a的时候用const修饰，并赋初值101，在此之后就不能再给a赋值了
a=101;   错误的
可以修饰指针

4. auto自动类型
现在基本不用
auto int a;和int a;是等价的

5. extern外部，用于函数，变量的声明

## 控制语句相关的关键字
1. if
2. else
3. break
4. continue
5. for
6. while
7. do while
8. switch case
9. go to跳转语句
10. default

## 其他关键字
1. sizeof测量大小
测量变量数组指针占用存储空间的大小(字节数)
`int a=10;
int num;
num=sizeof(a);`

2. typedef重命名
给一个已有的类型重新起个类型名，并没有创造一个新类型
`typedef short int int16;
int16 a;和short int a;效果一样`

3. volatile易改变
告诉cpu每次用volatile变量时，重新去内存中取，保证用的是最新的值，而不是寄存器中的备份
cpu用数据时，先把数据从内存中放到寄存器中然后再使用

# 基本类型
常量，程序运行过程中不可改变的量
变量，值可以改变的量

## 字符数据
### 字符常量:
直接常量:用单引号括起来的，如'a'，'b'，'0'等
转义字符
### 字符变量
用char定义，以ascii码形式存放在变量的内存单元中

字符串变量由双引号括起来的字符序列
每个字符串的结尾编译器都会自动添加一个结束标志位`\0`，即"a"包含两个字符'a'和`\0`

## 整形数据
### 整型常量：
十进制
八进制
十六进制
### 整型变量

## 实型数据（浮点型）
### 实型常量
也称实数或浮点数

十进制：0.12，5.0
指数形式：
123e3代表$123*10^3$
123e-3代表0.123

不以f结尾的常量实double类型的，以f结尾的常量是float类型的

# 基本类型的数据打印方法

## 格式化输出字符:

`%d `十进制有符号整数
`%u` 十进制无符号整数
`%x` 以十六进制表示的整数
`%o` 以八进制表示的整数
`%f` float 型浮点数
`%e`指数形式的浮点数
`%lf` double 型浮点数
`%s` 字符串
`%c` 单个字符
`%p` 指针的值

### 特殊应用:
`%3d`:要求宽度为3 位，如果不足 3 位，前面空格补齐:如果足够 3 位，此语句无效
`%03d`: 要求宽度为3 位，如果不足3 位，前面0 补齐:如果足够3 位，此语句无效
`%-3d`: 要求宽度为3 位，如果不足 3 位，后面空格补齐;如果足够 3 位，此语句无效
`%2f`: 小数点后只保留 2 位

# 构造类型
由若干个相同或不同类型数据构成的集合，这种数据类型被称为构造类型
如：数组、结构体、共用体、枚举
例：`int a[10];`

# 类型转换
当表达式中出现了 char 、short int 、int 类型中的一种或者多种，没有其他类型了，参加运算的成员全部变成 int类型的参加运算，结果也是 int 类型的

当表达式中出现了带小数点的实数，参加运算的成员全部变成 double 类型的参加运算，结果也是 double 型。

当表达式中有有符号数 也有无符号数，参加运算的成员变成无符号数参加运算结果也是无符号数.(表达式中无实数)

在赋值语句中等号右边的类型自动转换为等号左边的类型

注意自动类型转换都是在运算的过程中进行临时性的转换,并不会影响自动类型转换的变量的值和其类型

无论是强制转换或是自动转换，都只是为了本次运算的需要，而对变量的数据长度进行的临时性转换，而不改变数据定义的类型以及它的值

# 指针
# 算数运算符
## 双目运算符
参加运算的操作数有两个
+
-
*
/向下取整
%取余
如果进行除法运算后想要保留后面的小数只能设被除数为float


## 单目运算符
参加运算的操作数只有一个

`++`
自增运算符，给变量值+1
`i++
++i`

`int a=10;
a++;`

`--`
自减运算符，给变量值-1

`j--
--j`

## 三目运算符（条件运算符）
参加运算的操作数有三个
`()?():()`


## 优先级
先自增（自减）再乘除加减。

# 关系运算符
```c
>
<
==
>=
<=
!=
```

# 逻辑运算符
!非   &&与   ||或 ^异或
优先级：高-->低

# 原码反码补码
最高位为符号位，不参与运算
最高位为0是正数，为1是负数
对于正数，原码反码补码都是一样的
对于负数，负数的原码跟它的绝对值低位一样，最高位为1
负数的反码是除最高位符号位，其他位的数字取反
负数的补码是在它的反码加一
# 位运算符
无论正数还是负数，编译系统都按照内存中存储的内容进行位运算

## 位逻辑运算
将数据的二进制表示形式每一位进行逻辑运算运算

### `&`按位与

### `|`按位或

### `^`按位异或

### `~`按位取反
符号位也取反


## 位移运算
### `<<`左移
将数据的二进制形式的所有数向左移一位，溢出舍去空缺补零。

### `>>`右移
分为逻辑右移、算数右移
逻辑右移：高位补0，低位溢出
整数高位补0负数高位补1

例：
`0101 1010   >>3`
右边三位移出，左边三位补0
结果： 0000 1011

算数右移：高位补符号位（对无符号数），低位溢出（对有符号数）

例：
`1010 1101   >>3`
右边三位移出，左边三位补符号位（最高位）1
结果： 1111 0101

### `>>>`无符号右移
无符号右移不区分正负数都是溢出舍去空缺补0

# 条件运算符
是唯一的一个三目运算符
`()?():()`

`A?B:C`
如果A成立，则整个表达式的值为B，如果A不成立，则整个表达式的值为C

# 逗号运算符
`(),()`
结果是,后边的值
`a=(5,6)`
结果：a=6

用于让多个表达式按从左到右顺序依次求值

# 自增自减运算符
++自增运算符
--自减运算符
运算符在变量后面，在当前表达式先用变量的值，下条语句的时候i的值才改变。
运算符在变量前面，先改变变量，再运用到表达式中。
```c
int ×=10；
//后++：先用后加
//先把x变量中的值拿出来用，赋值给y，然后再进行自增。
//赋值给y的值是自增前的。
int y=x++;//x=11 y=10
//先++：先加后用
//先把x进行自增，然后把自增后的结果赋值给左边的变量
//先把x自增，变成12，然后再把自增之后的12赋值给z
int z=++×;//x=12 z=12
```

# 运算符的优先级

# 选择控制语句
## 1、if……else……
```c
if ()
{

}
else if()//相当于elif
{

}
else if()
{

}
else
{

}
```
## 2、switch……case……
```c
switch(表达式)//表达式只能是字符型或整形的（short int   int   long int
{
	case 常量表达式1:
		语句1;
		break;
	case 常量表达式2:
		语句2;
		break;
	default:
		语句3;
		break;
}
```
判断case后面的值是否与switch后面的值相同，若相同则执行case里面的语句，若不相同执行后面的语句。若所有case语句都没有相匹配则执行default里面的的语句。
也可以没有break，但没有break程序执行完符合条件的语句后不会再判断，而是直接执行后面的语句直到遇到break。

==如果在case里面定义了变量就需要把这个case块放到大括号里==

# 循环控制语句
## while……
## 形式1
进入 while 循环的时候，首先会判断条件表达式是否为真，为真进入循环体，否则退出循环
```c
while(条件表达式)
{
	复合语句
}
```

## 形式2   do……while……
先执行循环体里的代码，然后去判断条件表达式是否为真，为真再次执行循环体，否则退出循环
```c
do
{
	循环体
}while(条件表达式)
```

## for……
第一次进入循环的时候执行表达式1，表达式1只使用一次，
表达式2是循环的条件，只有表达式2为真才执行循环体，
每次执行完循环体后，首先执行表达式 3。
```c
for(表达式1;表达式2;表达式3)
{
	复合语句
}
```

# 跳转语句
## goto
跳转到标签所在的位置，标签可以放在goto语句前面也可以放在goto后面，也可以跳转到其他函数中，标签名随意定义
```c
goto tmp;
语句1
语句2
……
tmp：//标签
```
