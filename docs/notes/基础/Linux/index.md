---
title: 1 基础
createTime: 2025/06/18 20:42:50
permalink: /base/linux/
---
/bin：二进制可执行文件
/dev：设备文件
/etc：系统管理和配置文件
/home：用户主目录的起始基点
/lib：标准程序设计库
/sbin：系统管理命令
/tmp：公用的临时文件存贮点
/user：应用程序、软件包的配置文件
/var：某些大文件的溢出区
# 命令入门
```shell
command [-options] [parameter]
```
- command：命令本身
- -options：[可选,非必填]命令的一些选项,可以通过选项控制命令的行为细节
- parameter：[可选,非必填]命令的参数,多数用于命令的指向目标等
==语法中的[ ]，表示可选的意思==

示例:
- `ls-l/home/itheima`
ls是命令本身，-l是选项，/home/itheima是参数意思是以列表的形式，显示/home/itheima目录内的内容
- `cp-rtest1 test2`
cp是命令本身，-r是选项，test1和test2是参数意思是复制文件夹test1 成为 test2

# ls显示指令
ls命令的作用是列出目录下的内容
语法细节如下:
```shell
1s[-a -l -h] [Linux路径]
```
-a-l-h是可选的选项
-a是all的意思，表示列出全部文件（包含隐藏文件和文件夹）
**Linux系统中以.开头的文件或文件夹默认被隐藏**
-l是list的意思，表示以列表的形式展示内容，并展示更多信息
选项可以组合使用
```shell
ls -a -l
ls -al
ls -la
```
效果都是一样的

**使用-l显示出来的列表中以d开头的表示文件夹，以-开头的表示文件**

-h需要和-l搭配使用，以更人性化的方式显示文件的大小单位

Linux路径是此命令可选的参数
当不使用选项和参数,直接使用ls命令本体,表示以平铺形式,列出当前工作目录下的内容
加上参数表示列出指定目录下的内容，如：
```shell
ls /home            列出home目录下的内容
ls /               列出根目录下的内容
```

# 目录相关

## cd切换目录
change directory
```shell
cd [Linux路径]
```
cd命令直接执行表示回到用户的home目录
cd加路径表示切换到目标目录（以/开头表示绝对路径，相对路径不需要输入/）

#### 特殊路径符
- . 表示当前目录
	如：cd ./Desktop 表示切换到当前目录下的Desktop目录内，和cd Desktop效果一致
- .. 表示上一级目录
	如：cd.. 切换到上一级目录，cd ../.. 切换到上两级目录
- ~表示home目录，
	如：cd~ 切换到home目录 或cd ~/Desktop切换到home内的Desktop目录

## pwd展示目录
print work directory
```shell
pwd
```

## mkdir创建目录
make directory
```shell
mkdir [-p] Linux路径
```

```shell
mkdir ./test         表示在当前目录下创建名为test的文件夹
mkdir /home/pink/test       表示在pink目录下创建名为test的文件夹
mkdir ~/test          表示在home目录下创建名为test的文件夹
```

-p表示自动创建不存在的父目录，适用于创建连续多层级的目录

创建文件夹需要修改权限，尽量在home目录内创建，不要再home外操作
涉及到权限问题home外无法成功

# 文件操作

## touch创建文件
```shell
touch Linux路径
```

## cat查看文件内容
```shell
cat Linux路径
```

## more查看文件内容
more命令同样可以查看文件内容，与cat不同的是：
cat是直接将内容全部显示出来
more支持翻页，如果文件过多可以一页一页展示
```shell
more Linux路径
```
more展示出内容后按空格翻页查看，按回车按行查看
按b翻上一页
按q退出查看

## cp复制文件\\文件夹
copy
```shell
cp [-r] 参数1 参数2
```
-r：用于复制文件夹使用，表示递归（对于复制多层的文件夹使用）
参数1：Linux路径，表示被复制的文件或文件夹
参数2：Linux路径，表示复制到目标的地方

可复制到同目录文件夹并改名

## mv移动文件或文件夹
move
```shell
mv 参数1 参数2
```
参数1：Linux路径，表示被复制的文件或文件夹
参数2：Linux路径，表示复制到目标的地方
如果目标不存在mv有一个改名的效果确保目标存在

## rm删除文件\\文件夹

```shell
rm [-r -f] 参数1 参数2 …… 参数n
```
和cp一样-r用于删除文件夹
-f：表示force，强制删除（不会弹出提示确认信息），（在root用户删除操作时会弹出提示询问是否删除输入y表示删除，n表示取消）
普通用户删除内容不会弹出提示，只有root管理员用户删除内容会有提示（一般用户用不到-f选项）
参数表示要删除的文件或文件夹路径，可多参数批量删除
rm命令可以使用通配符来做模糊匹配
rm -rf/ 和rm -rf/* 删除Linux系统所有内容

# 通配符*
符号* 表示通配符，即匹配任意内容（包含空）
test* ：表示匹配任意以test开头的内容
\*test：表示匹配任何以test结尾的内容
\*test*：表示匹配任何包含test的内容

su - root 并输入密码可临时使用root权限
使用exit退回普通用户

# 查找命令

## which查找命令的命令
Linux命令本质上都是二进制可执行程序

使用which可查看所使用的一系列命令的程序文件存放在哪里
```shell
which 要查找的内容
```
## find查找文件
### 按文件名查找文件
```shell
find 起始路径 -name "被查找文件名"
```
起始路径表示从哪里开始搜索
也可以使用通配符进行搜索
### 按文件大小查找文件
```shell
find 起始路径 -size +|-n[kMG]
```
+、-表示大于和小于
n表示大小数字
kMG表示大小单位。k（小写）表示kb，M表示MB，G表示GB

示例：
从根目录中查找小于10kb的文件：find / -size -10k
查找大于100MB的文件：find / -size +100M
查找大于1GB的文件：find / -size +1G

### 按文件类型查找
```shell
find 起始路径 -type 类型名
```

| 文件类型    | 类型的字符描述 |
| ------- | ------- |
| 普通文件类型  | f       |
| 目录类型    | d       |
| 软连接类型   | l       |
| 字符设备类型  | c       |
| 块设备类型   | b       |
| 管道类型    | p       |
| 本地套接字类型 | s       |

## 目录层级
目录可能有很多层, 在搜索某些属性的时候可以指定只搜索某几层目录, 相关的参数有两个, 分别为: `-maxdepth`和`-mindepth`。
这两个参数不能单独使用， 必须和其他属性一起使用，也就是搜索某几层目录中满足条件的文件。
- `-maxdepth`: 最多搜索到第多少层目录 ,
- `-mindepth`: 至少从第多少层开始搜索
```shell
# 查找文件, 从根目录开始, 最多搜索5层, 这个文件叫做 *.txt (1 <= 层数 <= 5)  
sudo find / -maxdepth 5 -name "*.txt"  
# 查找文件, 从根目录开始, 至少从第5层开始搜索, 这个文件叫做 *.txt (层数>=5层)  
sudo find / -mindepth 5 -name "*.txt"
```

## 同时执行多个操作
find无法配合管道符工作，但若想实现其需求可以使用exec、ok、xargs选项
### exec
`-exec` 是find的参数, `可以在exec参数后添加其他需要被执行的shell命令`。
find 添加了 exec 参数之后, 命令的`尾部需要加`一个后缀 `{} \;`, 注意 `{}`和`\`之间需要有一个空格。
在参数`-exec`后添加的shell命令处理的是find搜索之后的结果, find的结果会作为 新添加的shell命令 的输入，最后在终端上输出最终的处理结果。
```shell
ind 路径 参数 参数值 -exec shell命令2 {} \
```

### ok
`-ok` 和 `-exec` 都是`find`命令的参数, 使用方式类似, 但是这个参数是交互式的, 在处理`find`的结果的时候, 会向用户发起询问，比如在删除搜索结果的时候，为了保险起见，就需要询问机制了。
```shell
find 路径 参数 参数值 -ok shell命令2 {} \
```

### xargs
在使用`find`的`-exec`参数的时候, 需要在指定的子命令尾部添加几个特殊字符`{} \;`，一不小心就容易写错，有一种看起来更加直观、书写更加简便的方式，我们可以使用 `xargs`替换掉`-exec`参数, 而且在处理数据的时候`xargs更高效`。有了`xargs`的加持我们就可以在`find`命令中直接使用管道完成前后命令的数据传递
```shell
find 路径 参数 参数值 | xargs shell命令2
```
 
 xargs的效率比使用 -exec 效率高  
	-exec:  将find查询的结果逐条传递给后边的shell命令  
	-xargs: 将find查询的结果一次性传递给后边的shell命令

## grep过滤文件内容
从文件中通过关键字过滤文件行
```shell
grep [-n] 关键字 文件路径
```
-n表示在结果中显示匹配的行的行号
关键字：表示过滤的关键字，带有空格或其它特殊符号，建议使用””将关键字包围起来
文件路径：表示要过滤内容的文件路径，可作为内容输入端口

## local
我们可以将`locate`看作是一个简化版的`find`, 使用这个命令我们可以`根据文件名搜索本地的磁盘文件`, 但是`locate的效率比find要高很多`。原因在于它不搜索具体目录，而是搜索一个本地的数据库文件，这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，`可以在使用locate之前，先使用updatedb命令，手动更新数据库。`
使用管理员权限更新本地数据库文件, 非root用户需要加 sudo  
```shell
updatedb
```

1. 搜索所有目录下以某个关键字开头的文件
```shell
locate 路径名/关键字 [-i\n\r]
```
搜索指定路径下以该关键字开头的文件。路径必须为绝对路径，若不指定路径则默认是所有路径
```shell
locate /home/robin/test    # 指定搜索目录为 /home/robin/, 文件以 test 开头
```

-i：忽略文件名的大小写
```shell
locate TEST -i	# 文件名以小写的test为前缀的文件也能被搜索到
```
-n：列出前N个匹配到的文件名称或路径名称
```shell
locate test -n 5		# 搜索文件前缀为 test 的文件, 并且只显示5条信息
```
-r：基于`正则表达式`进行文件名匹配, 查找符合条件的文件
```shell
locate -r "\.cpp$"		# 搜索以 .cpp 结尾的文件
```

> [!important] 正则表达式小科普:
> 1. 在正则表达式中 `.`可以匹配任意一个 非 `\n`的单字符
> 2. 上边的命令中使用转译字符`\`对特殊字符`.`转译, 就得到了普通的字符`.`
> 3. 在正则表达式中 `$`放到字符尾部, 表示字符串必须以这个字符结尾, 上边的命令中修饰的是字符`p`
> 4. 正则表达式中的 字符`c`和后边的字符`p`需要进行字节匹配, 没有特殊含义
> 5. 通过上面的解释就能明白 `\.cpp$` 说的就是以 `.cpp`结尾的字符串

## wc统计文件内容数量
```shell
wc [-c -m -l -w] 文件路径
```
-c：统计bytes数量
-m：统计字符数量
-l：统计行数
-w：统计单词数量（按空格划分）
文件路径：被统计的文件，==可作为内容输入端口==
## |管道符
管道符也可嵌套使用
至此有输入输出的命令都可以使用管道符

将左边命令的结果作为右边命令的输入
```shell
cat text.txt | grap "pink"
```
右边的grap命令还缺少一个文件路径使用管道符将cat text.txt作为输入

## echo命令
在命令行内输出指定内容
```shell
echo 输出的内容
```
复杂内容可使用“”包裹

```shell
echo hello world
```
在终端中显示hello world

如果带有空格或\\等特殊符号建议使用双引号包裹，不包裹的话容易被认为是命令的语义

## \`反引号
使被它包裹的内容会作为命令去执行
```shell
echo pwd         在终端中输出pwd
echo `pwd`       输出pwd的输出
```

## 重定向符

### >和>>
只要能产生输出的都能写在重定向符前面

\>：将左侧命令的结果，覆盖写入到符号右侧指定的文件中
\>>：将左侧命令的结果，追加写入到符号右侧指定的文件中
```shell
echo "hello world">test.txt
```
v执行这个命令后test.txt里面原本的内容就被hello world取代了
```shell
echo "hello linux">>test.txt
```
将hello linux追加到test.txt文件中

## tail命令
查看文件尾部内容，跟踪文件的最新更改
```shell
tail [-f -num] Linux路径
```
Linux路径：表示被跟踪的文件路径选项
-f：表示持续跟踪（文件中新增的内容会立即显示出来）使用ctrl+c可强制停止
-num：表示查看尾部多少行，不填默认10行

# vi\\vim编辑器

底行命令模式会在最后一行显示一个冒号，如果要区分输入模式和命令模式最好的办法是输入一个冒号如果正常输入一个冒号则为输入模式，如果输入的冒号在底部显示出来则为命令模式
## 命令模式(Command mode)
命令模式下，所敲的按键编辑器都理解为命令，以命令驱动执行不同的功能此模型下，不能自由进行文本编辑。
分别使用vi和vim打开文件
```shell
vi 文件路径
vim 文件路径
```
如果文件路径表示的文件不存在，那么此命令会用手编辑新文件
如果文件路径表示的文件存在少那么此命令用于编辑已有文件

重做 .
搜索 / ？
## 输入模式(Insert mode)
也就是所谓的编辑模式、插入模式。此模式下可以对文件内容进行自由编辑
## 底行命令模式(Last line mode)
以:开始，通常用于文件的保存、退出

# 命令行参数

常见的main函数原型：
```c
int main(void)
int main(int argc,char* argv[])
int main(int argc,char* argv[],char* env[])
```
argc：命令行参数的个数，至少为1，./app运行程序也算命令
argv：命令行参数
env：环境变量的指针数组，用于获取系统传递给进程的环境变量的值，一般很少使用

对于复杂命令选项参数的判断，直接判断argc和argv比较麻烦，可以使用getopt函数来分析命令行参数
```c
int getopt(int argc,char* argv[],const char* optstring);
```
optstring：选项字符串，代表命令选项的格式，如果选项字符后跟着一个冒号，表示该选项选择需要一个参数，这个参数可以与选项连着或间隔一个空格。如果选项字符后跟着两个冒号，表示该选项的参数是可选的，即使有参数必须连写，不能间隔空格
如果在命令行参数发现选项字符，则返回该选项字符，如果所有的命令行参数都已经被分析完，则返回-1

# 环境变量
## shell变量
shell是一个特殊的进程，是用户与内核之间的接口，shell启动后拥有多个自己的变量，对环境变量的访问主要包括查看、定义、修改、删除

**查看**
```shell
echo $变量名
如： echo $HOME输出登录用户的主目录
```
查看当前shell中所有的环境变量信息可以使用set命令，常用的环境变量有HOME（用户主目录）、PWD（当前工作目录）、PATH（默认可执行程序搜索路径）等，这些变量在用户登录系统后由系统自动设置

**定义和修改**
shell允许用户自定义环境变量
```shell
[export] 变量名=变量值1:变量值2......
```
直接定义的环境变量只能被shell本身访问，不能被在shell中启动的其他应用程序访问
如果在该变量前加上export命令，则该变量可以被shell中启动的其他应用程序访问，可以在定义变量的同时使用export命令，也可以在定义变量后单独使用
若要给一个变量添加多个值需要用:隔开
修改环境变量和定义的语法相同，若在修改时保留原变量值的同时添加一些值需要先引用原来的值
```shell
export PATH=$PATH:.
```

**删除**
```shell
unset 变量名
```
使用命令方式对变量做出的改变无论是增删改都是临时的，当系统重新启动后将恢复到改变之前的状况，这是因为Linux系统启动过程中是通过读取系统配置文件来确定各变量的值，使用命令方式对环境变量表的改动并没有记录入文件，所以重新启动后会恢复原状。如果要想在系统重新启动后仍然保持对环境变量的改动需要将改动写入到文件中，在/etc/profile中或用户主目录的.bash_profile。
前者文件中的修改结果所有登录用户都能访问，二后者文件中修改只有某个用户才能访问。

### 环境变量相关函数
```c
//获取环境变量。name要获取的环境变量名。成功获取 环境变量时，返回一个指向环境变量值的指针，如果没有获取环境变量则返回空指针NULL
char* getenv(const char* name)

//改变或增加环境变量。string要改变或增加的环境变量表达式，执行成功返回0，失败返回-1
int putenv(char* string)
//改变或增加一个环境变量。
//name环境变量名。value环境变量值。overwrite是否覆盖环境变量原值，0不覆盖，非0覆盖
//成功返回0，失败返回-1
int setenv(const char* name,const char* value,int overwrite)
//删除一个环境变量。
//name要删除的环境变量名
//成果返回0，失败返回-1并设置errno
void unsetenvc(const char* name)
```

# 时间管理
可以使用date命令获取当前日期和时间
![](attachments/Pasted%20image%2020250711223201.png)
通过time系统调用从系统获取当前的时间得到的时间类型是time_t，但不容易阅读可以使用其他函数转换为字符串或struct tm类型
在通过stime系统调用设置时间也需要转换为time_t类型
```c
struct tm{
	int tm_sec;    //秒，范围0~61，2秒闰秒
	int tm_min;    //分钟，范围0~59
	int tm_hour;    //小时，范围0~23
	int tm_mday;    //一个月内的日期，范围1~31
	int tm_mon;    //月份，范围0~11
	int tm_year;    //年，自1900年开始计算，如：108相当于2008
	int tm_wday;    //星期，范围0~6
	int tm_yday;    //一年中的日期，范围0~365
	int tm_isdst;    //夏令时标记（>0夏令时有效，0无效，-1不可用）
}
```

**获取时间相关函数**
time_t本质上就是一个long int型
成功则返回以秒为单位的UNIx时间戳，失败则返回（time_t）-1
```c
//获取当前日期和时间，可以通过参数获取也可以通过返回值
time_t time(time_t* tloc)
```

生成随机数
返回一个O-RAND_MAX之间的伪随机数。当前机器环境下，RAND_MAX为int类型的最大值@return int 伪随机数
```c
int rand(void);
```

将seed设置为rand（）生成随机数时使用的随机种子，如果没有设置随机种子，rand（)会自动将1作为随机种子
seed随机种子
```c
void srand(unsigned int seed);
```
